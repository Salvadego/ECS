// Code generated by gen_queries.go; DO NOT EDIT.

package ecs

import "reflect"

//

// Tuple1 holds 1 component pointers.
type Tuple1[C1 any] struct {
	C1 C1
}

// Query1 returns a slice of Tuple1 for every entity matching the filter.
func Query1[C1 any](
	f Filter, w *World,
) []Tuple1[C1] {
	var out []Tuple1[C1]

	// 1) map each generic type to ComponentID
	t1 := reflect.TypeOf((*C1)(nil)).Elem()
	id1 := w.registry.GetComponentID(t1)

	// 2) prepare excludeIDs
	var excludeIDs []ComponentID
	for _, exT := range f.exclude {
		excludeIDs = append(excludeIDs, w.registry.GetComponentID(exT))
	}

	// 3) scan archetypes
	for _, arch := range w.archetypes {
		if !arch.signature.Has(id1) {
			continue
		}

		skip := false
		for _, exID := range excludeIDs {
			if arch.signature.Has(exID) {
				skip = true
				break
			}
		}
		if skip {
			continue
		}
		data1 := arch.components[id1]

		// 4) build results
		for i := range arch.entities {
			ptr1, ok1 := data1[i].(C1)
			if !ok1 {
				continue
			}

			out = append(out, Tuple1[C1]{
				C1: ptr1,
			})
		}
	}

	return out
}

// Tuple2 holds 2 component pointers.
type Tuple2[C1 any, C2 any] struct {
	C1 C1
	C2 C2
}

// Query2 returns a slice of Tuple2 for every entity matching the filter.
func Query2[C1 any, C2 any](
	f Filter, w *World,
) []Tuple2[C1, C2] {
	var out []Tuple2[C1, C2]

	// 1) map each generic type to ComponentID
	t1 := reflect.TypeOf((*C1)(nil)).Elem()
	id1 := w.registry.GetComponentID(t1)
	t2 := reflect.TypeOf((*C2)(nil)).Elem()
	id2 := w.registry.GetComponentID(t2)

	// 2) prepare excludeIDs
	var excludeIDs []ComponentID
	for _, exT := range f.exclude {
		excludeIDs = append(excludeIDs, w.registry.GetComponentID(exT))
	}

	// 3) scan archetypes
	for _, arch := range w.archetypes {
		if !arch.signature.Has(id1) {
			continue
		}
		if !arch.signature.Has(id2) {
			continue
		}

		skip := false
		for _, exID := range excludeIDs {
			if arch.signature.Has(exID) {
				skip = true
				break
			}
		}
		if skip {
			continue
		}
		data1 := arch.components[id1]
		data2 := arch.components[id2]

		// 4) build results
		for i := range arch.entities {
			ptr1, ok1 := data1[i].(C1)
			if !ok1 {
				continue
			}
			ptr2, ok2 := data2[i].(C2)
			if !ok2 {
				continue
			}

			out = append(out, Tuple2[C1, C2]{
				C1: ptr1,
				C2: ptr2,
			})
		}
	}

	return out
}

// Tuple3 holds 3 component pointers.
type Tuple3[C1 any, C2 any, C3 any] struct {
	C1 C1
	C2 C2
	C3 C3
}

// Query3 returns a slice of Tuple3 for every entity matching the filter.
func Query3[C1 any, C2 any, C3 any](
	f Filter, w *World,
) []Tuple3[C1, C2, C3] {
	var out []Tuple3[C1, C2, C3]

	// 1) map each generic type to ComponentID
	t1 := reflect.TypeOf((*C1)(nil)).Elem()
	id1 := w.registry.GetComponentID(t1)
	t2 := reflect.TypeOf((*C2)(nil)).Elem()
	id2 := w.registry.GetComponentID(t2)
	t3 := reflect.TypeOf((*C3)(nil)).Elem()
	id3 := w.registry.GetComponentID(t3)

	// 2) prepare excludeIDs
	var excludeIDs []ComponentID
	for _, exT := range f.exclude {
		excludeIDs = append(excludeIDs, w.registry.GetComponentID(exT))
	}

	// 3) scan archetypes
	for _, arch := range w.archetypes {
		if !arch.signature.Has(id1) {
			continue
		}
		if !arch.signature.Has(id2) {
			continue
		}
		if !arch.signature.Has(id3) {
			continue
		}

		skip := false
		for _, exID := range excludeIDs {
			if arch.signature.Has(exID) {
				skip = true
				break
			}
		}
		if skip {
			continue
		}
		data1 := arch.components[id1]
		data2 := arch.components[id2]
		data3 := arch.components[id3]

		// 4) build results
		for i := range arch.entities {
			ptr1, ok1 := data1[i].(C1)
			if !ok1 {
				continue
			}
			ptr2, ok2 := data2[i].(C2)
			if !ok2 {
				continue
			}
			ptr3, ok3 := data3[i].(C3)
			if !ok3 {
				continue
			}

			out = append(out, Tuple3[C1, C2, C3]{
				C1: ptr1,
				C2: ptr2,
				C3: ptr3,
			})
		}
	}

	return out
}

// Tuple4 holds 4 component pointers.
type Tuple4[C1 any, C2 any, C3 any, C4 any] struct {
	C1 C1
	C2 C2
	C3 C3
	C4 C4
}

// Query4 returns a slice of Tuple4 for every entity matching the filter.
func Query4[C1 any, C2 any, C3 any, C4 any](
	f Filter, w *World,
) []Tuple4[C1, C2, C3, C4] {
	var out []Tuple4[C1, C2, C3, C4]

	// 1) map each generic type to ComponentID
	t1 := reflect.TypeOf((*C1)(nil)).Elem()
	id1 := w.registry.GetComponentID(t1)
	t2 := reflect.TypeOf((*C2)(nil)).Elem()
	id2 := w.registry.GetComponentID(t2)
	t3 := reflect.TypeOf((*C3)(nil)).Elem()
	id3 := w.registry.GetComponentID(t3)
	t4 := reflect.TypeOf((*C4)(nil)).Elem()
	id4 := w.registry.GetComponentID(t4)

	// 2) prepare excludeIDs
	var excludeIDs []ComponentID
	for _, exT := range f.exclude {
		excludeIDs = append(excludeIDs, w.registry.GetComponentID(exT))
	}

	// 3) scan archetypes
	for _, arch := range w.archetypes {
		if !arch.signature.Has(id1) {
			continue
		}
		if !arch.signature.Has(id2) {
			continue
		}
		if !arch.signature.Has(id3) {
			continue
		}
		if !arch.signature.Has(id4) {
			continue
		}

		skip := false
		for _, exID := range excludeIDs {
			if arch.signature.Has(exID) {
				skip = true
				break
			}
		}
		if skip {
			continue
		}
		data1 := arch.components[id1]
		data2 := arch.components[id2]
		data3 := arch.components[id3]
		data4 := arch.components[id4]

		// 4) build results
		for i := range arch.entities {
			ptr1, ok1 := data1[i].(C1)
			if !ok1 {
				continue
			}
			ptr2, ok2 := data2[i].(C2)
			if !ok2 {
				continue
			}
			ptr3, ok3 := data3[i].(C3)
			if !ok3 {
				continue
			}
			ptr4, ok4 := data4[i].(C4)
			if !ok4 {
				continue
			}

			out = append(out, Tuple4[C1, C2, C3, C4]{
				C1: ptr1,
				C2: ptr2,
				C3: ptr3,
				C4: ptr4,
			})
		}
	}

	return out
}

// Tuple5 holds 5 component pointers.
type Tuple5[C1 any, C2 any, C3 any, C4 any, C5 any] struct {
	C1 C1
	C2 C2
	C3 C3
	C4 C4
	C5 C5
}

// Query5 returns a slice of Tuple5 for every entity matching the filter.
func Query5[C1 any, C2 any, C3 any, C4 any, C5 any](
	f Filter, w *World,
) []Tuple5[C1, C2, C3, C4, C5] {
	var out []Tuple5[C1, C2, C3, C4, C5]

	// 1) map each generic type to ComponentID
	t1 := reflect.TypeOf((*C1)(nil)).Elem()
	id1 := w.registry.GetComponentID(t1)
	t2 := reflect.TypeOf((*C2)(nil)).Elem()
	id2 := w.registry.GetComponentID(t2)
	t3 := reflect.TypeOf((*C3)(nil)).Elem()
	id3 := w.registry.GetComponentID(t3)
	t4 := reflect.TypeOf((*C4)(nil)).Elem()
	id4 := w.registry.GetComponentID(t4)
	t5 := reflect.TypeOf((*C5)(nil)).Elem()
	id5 := w.registry.GetComponentID(t5)

	// 2) prepare excludeIDs
	var excludeIDs []ComponentID
	for _, exT := range f.exclude {
		excludeIDs = append(excludeIDs, w.registry.GetComponentID(exT))
	}

	// 3) scan archetypes
	for _, arch := range w.archetypes {
		if !arch.signature.Has(id1) {
			continue
		}
		if !arch.signature.Has(id2) {
			continue
		}
		if !arch.signature.Has(id3) {
			continue
		}
		if !arch.signature.Has(id4) {
			continue
		}
		if !arch.signature.Has(id5) {
			continue
		}

		skip := false
		for _, exID := range excludeIDs {
			if arch.signature.Has(exID) {
				skip = true
				break
			}
		}
		if skip {
			continue
		}
		data1 := arch.components[id1]
		data2 := arch.components[id2]
		data3 := arch.components[id3]
		data4 := arch.components[id4]
		data5 := arch.components[id5]

		// 4) build results
		for i := range arch.entities {
			ptr1, ok1 := data1[i].(C1)
			if !ok1 {
				continue
			}
			ptr2, ok2 := data2[i].(C2)
			if !ok2 {
				continue
			}
			ptr3, ok3 := data3[i].(C3)
			if !ok3 {
				continue
			}
			ptr4, ok4 := data4[i].(C4)
			if !ok4 {
				continue
			}
			ptr5, ok5 := data5[i].(C5)
			if !ok5 {
				continue
			}

			out = append(out, Tuple5[C1, C2, C3, C4, C5]{
				C1: ptr1,
				C2: ptr2,
				C3: ptr3,
				C4: ptr4,
				C5: ptr5,
			})
		}
	}

	return out
}
